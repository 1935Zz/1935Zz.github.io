---
title: 数据密集型应用系统设计-第四章-数据
date: 2025-09-28 20:39:32
categories:
   - [Read-Note, 数据密集型应用系统设计]
---

对于⼀个应⽤系统，如果“数据”是其成败决定性因素，包括数据的规模、数据的复杂度或者数据产⽣与变化的速率等，我们就可以称为“数据密集型应⽤系统”，与之对应的是计算密集型（Compute-Intensive），CPU 主频往往是后者最⼤的制约瓶颈

# 数据系统基础

## 四、数据编码与演化

> 向后兼容较新的代码可以读取由旧代码编写的数据。
>
> 向前兼容较旧的代码可以读取由新代码编写的数据

### 数据编码格式

两种表示

* 在内存中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些数据结构针对 CPU 的高效访问和操作进行了优化（通常使用指针）。

* 将数据写入文件或通过网络发送时，必须将其编码为某种自包含的字节序列（例如 JSON 文档）

从内存中的表示到字节序列的转化称编码（或序列化等），相反的过程称为解码（或解析，反序列化）

语言内置的编码库存在问题，包括和语言绑定、兼容性、效率

**JSON、XML、CSV&#x20;**&#x4F5C;为数据交换格式收到欢迎，尽管存在缺点，包括：

* 数字编码的模糊，XML 和 CSV 无法区分数字和数字组成的字符串，JSON 不区分整数和浮点数

* JSON 和 XML 不支持字节序列

* JSON 和 XML 支持 schema，但 CSV 不支持

**二进制编码**

编码大小可能更小，解析可能更快

![](image-12.png)

MessagePack

![](image-13.png)

**Thrift 和 ProtocolBuffers**

需要 schema 来编码，使用代码生成工具生成支持多种语言的类，可以调用生成的代码来编码或解码 schema

Thrift 使用 idl 描述模式，ProtocolBuffers 类似

Thrift 有 2 种二进制编码格式，分别为 BinaryProtocol 和 CompactProtocol

![](image-2.png)

![](image-5.png)

ProtocolBuffers 有一种

![](image-14.png)

required 和 optional 不记录在编码中，区别于，required 字段如果未填充运行检查出错，可用于捕获错误

模式演化同时保持向后和向前兼容

不能更改标签（数字 1，2，3）（导致现有编码无效），可更改字段名称，可添加新字段（旧读新直接忽略，新读旧新添字段只能为 optional），可删除字段（类似添加字段，只能删除 optional 字段，不能再使用相同标签号）

数据类型演化，32 位变为 64 位可以向前兼容，但无法向后兼容

ProtocolBuffers 无列表或数组类型，repeated 标记表示一个字段重复多次出现，可以将 optional（单值）转变为 repeated，新读旧看到包含 1 个或 0 个元素列表，旧读新只看到列表最后一个元素

Thrift 有专用列表数据类型，不支持单值到多值，但有支持嵌套列表优点

**Avro**

用于适配 Hadoop

两种模式语言，AvroIDL 和基于 JSON

![](image-1.png)

![](image.png)

编码无类型信息，按照出现的顺序遍历解析字段，所以模式必须完全匹配

写模式和读模式不必完全一样，保持兼容即可，数据被读取时，Avro 库通过对比查看写模式和读模式并将数据从写模式转换为读模式来解决其差异

![例如，如果写模式和读模式的字段顺序不同，这也没有问题，因为模式解析通过字段名匹配字段。如果读取数据的代码遇到出现在写模式但不在读模式中的字段，则忽略它。如果读取数据的代码需要某个字段，但是写模式不包含该名称的字段，则使用在读模式中声明的默认值填充。](image-28.png)

使用 Avro，向前兼容意味着可以将新版本的模式作为 writer，并将旧版本的模式作为 reader。相反，向后兼容意味着可以用新版本的模式作为 reader，并用旧版本的模式作为 write

reader 如何确定特定数据采用哪个 writer？取决于上下文

*很多记录大文件*

avro 常见用途，存储大量记录大文件，所有记录采用相同的模式，writer 可以在文件开头包含 writer 的模式信息

*单独记录写入数据库*

不同记录模式会不同，每个编码记录开始包含一个版本号，在数据库中保留一个模式版本列表，reader 根据记录的版本号查询对应的 writer 模式（Espresso）

*网路连接发送记录*

两个进程通过双向网络通信，可以在建立连接是协商模式版本，连接的生命周期中使用该模式（AvroRPC 协议原理）

Avro 本质是动态生成模式，模式中不包含标签号，字段通过名字标识，比如记录数据库每个表的模式，如果发生变化，可以直接动态生成新的 Avro 模式，更新的 writer 可以适配旧的 reader，而 Thrift 和 ProtocolBuffers 可能必须手动分配字段标签，需要维护列名到字段标签的映射

Thrift 和 ProtocolBuffers 依赖代码生成特性，适合静态语言，可以类型检查

Avro 可选代码生成，也可以不生成代码，在对象容器文件中包含元数据，使用 Avro 库打开它

基于模式的二进制编码的优点

* 比 JSON 更紧凑，可省略字段名称

* 模式是一种有价值的文档形式，必须保持最新，手动维护的文档可能过期

* 模式数据库允许在部署任何内容之前检查模式更改的向前和向后兼容性

* 对于静态类型编程语言的用户来说，从模式生成代码的能力是有用的，它能够在编译时进行类型检查

### 数据流模式

进程间（非共享内存）数据流

**通过网络或写入文件，将数据编码为字节序列**，一个编码，一个解码，独立升级不同部分，兼容性

**通过数据库**

可能只有一个进程访问，必须向后兼容

可能较新版本写入，较旧版本读，需要向前兼容

![](image-23.png)

数据重写为新模式，但代价较高，可以添加默认值为空而不重写，读取旧行为编码数据缺失的列填充为空值

底层存储可能包含多个版本模式，但整个数据库看起来像采用单个模式编码

归档存储，通常用最新模式编码

**通过服务调用**

REST 和 RPC

客户端（web 浏览器），javascript 客户端（Ajax）->web 服务器

SOA，微服务

两种流行 Web 服务：REST 和 SOAP

REST：基于 HTTP 原则，强调简单的数据格式，URL 表示资源，HTTP 功能缓存控制、身份验证和内容类型协商

SOAP：基于 XML 协议，API 请求，独立于 HTTP，避免使用大多数 HTTP 功能，有复杂的多种标准和新增功能，用 WSDL（WebServicesDescriptionLanguage，一种基于 XML 的语言）描述 API，依赖工具支持、代码生成和 IDE

RPC：远程过程调用，远程网络服务发出请求看起来与在同一进程中调用编程语言中的函数或方法相同

存在缺陷，网络请求和本地函数调用的不同：

* 本地函数调用是可预测的，并且成功或失败仅取决于控制的参数。网络请求不可预测（网络问题，远程服务器不可用……）

* 本地函数调用要么返回一个结果，要么抛出一个异常，或者永远不会返回（循环或进程崩溃）。网络请求另一个结果（一直收不到响应）

* 重试失败可能是请求已完成，但是响应丢失，重试会执行多次，幂等性问题

* 本地调用时间大致相同，网络请求可能因为网络阻塞或远程服务过载导致不同的时间

* 本地函数可以传递指针，网络请求需要编码成网络可以发送的字节序列，需要考虑较大的对象

* 网络请求有客户端和服务端语言不同的情况

二进制编码的自定义 RPC 协议，相比诸如 REST 的 JSON 类通用协议性能更好

RESTfulAPI 优点，有利于实验和调试，支持所有主流语言和平台，有庞大的工具生态系统。因此 REST 是公共 API 的主流风格，RPC 框架侧重于同一组织内不同服务之间的请求

向后向前兼容性取决于它所使用的具体编码技术，Thrift、gRPC 的编码格式，SOAP 的 XML 模式请求和响应，RESTfulAPIJSON 响应和 JSON 或 URI 编码的请求参数

**通过异步消息传递**

以低延迟传递到另一个进程（RPC 类似），不通过直接的网络连接发送消息，通过称为消息队列的中介发送

和 RPC 相比优点

* 接收方不可用中介可以充当缓冲区，提高可靠性

* 可以自动将消息重新发送到崩溃的进程，防止消息丢失

* 避免发送方需要知道接收方的 IP 地址和端口号

* 支持一条消息发送给多个接收方

* 逻辑上发送方和接收方分离

消息传递单向，发送方不期望收到回复

分布式 actor 框架

Actor 模型是用于单个进程中并发的编程模型。逻辑被封装在 Actor 中，而不是直接处理线程（以及竞争条件、锁定和死锁的相关问题）。每个 Actor 通常代表一个客户端或实体，它可能具有某些本地状态（不与其他任何 Actor 共享），并且它通过发送和接收异步消息与其他 Actor 通信。不保证消息传送：在某些错误情况下，消息将丢失。由于每个 Actor 一次只处理一条消息，因此不需要担心线程，每个 Actor 都可以由框架独立调度。

在分布式 Actor 框架中，这个编程模型被用来跨越多个节点来扩展应用程序。无论发送方和接收方是在同一个节点上还是在不同的节点上，都使用相同的消息传递机制。如果它们位于不同的节点上，则消息被透明地编码成字节序列，通过网络发送，并在另一端被解码



