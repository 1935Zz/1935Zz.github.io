---
title: 数据密集型应用系统设计-第三章-数据存储与检索
date: 2025-09-28 20:39:32
categories:
   - [Read-Note, 数据密集型应用系统设计]
---


# 数据系统基础

## 三、数据存储与检索

### **数据结构**

对于 kv 存储，最简单，存储到一个文件中，每行记录一对 key，value。读效率低，但写效率快

索引：基于原始数据派生而来的额外数据结构，能够加速查询，通常会降低写的速度

**哈希索引**

如果是追加式文件，可以用一个 hashmap，保存到内存中，每个 key 映射到数据文件中在磁盘上的字节偏移量（Bitcask 存储引擎）

为了避免用尽磁盘空间，可以将日志分解成多个小段，每个小段维护一个 hashmap，同时可以对段压缩及合并（丢弃重复的键，保留最新的键的更新，可以用后台线程）

考虑额外的几个问题

1. 文件格式，csv 非最佳，更好的是采用二进制格式（占用空间更小）

2. 删除记录，对于删除场景，需要在文件中追加一个删除标记，合并时发现标记，则丢弃删除键

3. 崩溃恢复，数据库重启会使内存中的 hashmap 丢失，可以重新读取文件构建 hash，但较慢，可以将每个段的 hashmap 快照存储在磁盘上，以便重启后直接加载到内存中

4. 并发控制，写入有先后顺序，通常只有一个写线程，多个读线程

追加日志优势：

1. 顺序写，比随机写快（磁盘特性）

2. 段文件追加及不可变特性，并发和崩溃恢复简单，例如不会出现重写崩溃的时候新旧值混合

3. 合并旧段避免了文件碎片化

哈希索引局限：

1. 必须全部放入内存，不适合大量的键，放入磁盘性能差（随机访问），以及哈希冲突

2. 区间查询效率低

**SSTables 和 LSM-Tree**

SSTable：排序字符串表，要求文件格式 kv 按 key 排序，每个键在每个段文件只出现一次

相比哈希索引优点

1. 合并高效，并发读取多个段，比较每个段第一个键，取最小的拷贝到输出文件

2. 查找无需保存所有键索引，保存 A 和 B 的索引，可以索引查找 A 到 B 之间所有 key，区间查找高效

SSTable 构建和维护。可以采用红黑树或 AVL 树作为内存排序

* 分块存储，可压缩

写入立即追加到日志，用于崩溃恢复

应用：leveldb，rocksdb，Cassandra

LSM-Tree（Log-StructuredMerge-Tree）：日志结构合并树，基于合并和压缩排序文件原理

lucene，全文搜索索引引擎，kv 结构，key 是单词，value 是 id 列表，类 SSTable 排序文件保存映射关系

优化

* 布隆过滤器判断 key 不存在

* SSTables 压缩和合并是的顺序和实际，大小分级和分层存储

**B-trees**

常用于关系数据库

WAL 崩溃恢复，锁控制并发

![](https://cdn.jsdelivr.net/gh/1935Zz/1935zz.github.io@main/source/img/data-intensive/diagram.png)

**其它索引结构**

二级索引，用于执行联结操作

聚集索引（在索引中直接保存行数据）

非聚集索引（仅存储索引中的数据的引用，行存放在堆文件），存放多个二级索引避免了复制数据

覆盖索引（索引中保存一些表的列值）

### 事务处理与分析处理

![](https://cdn.jsdelivr.net/gh/1935Zz/1935zz.github.io@main/source/img/data-intensive/image-4.png)

放弃用 OLTP 用于分析，用单独的数据库进行分析

**数据仓库**

不影响 OLTP，从 OLTP 提取数据，分析友好

![提取-转换-加载(Extract-Transform-Load,ETL)](https://cdn.jsdelivr.net/gh/1935Zz/1935zz.github.io@main/source/img/data-intensive/image-3.png)

事实表：星型模式的中心，每一行表示在特定时间发生的事件，数据量大，列数大

由于每次只读取一行中的少数几列，面向行的存储引擎仍需要将所有行从磁盘加载到内存中，效率较低

需要在大量行顺序扫描，索引重要性降低，更重要的是紧凑编码数据，减少磁盘读取数据量，出现列存储

### 列存储

适用于 OLAP 系统

列存储：不要将一行中的所有值存储在一起，而是将每列中的所有值存储在一起

列压缩：对每列的值序列压缩，可以采用位图编码，n 个不同的列值，用 n 个位图，每一位（0/1）表示该行的值是否是对应的列值

写操作：LSM-tree，先写入内存存储区（面向行或面向列皆可），添加到已排序结构中，再准备写入磁盘，累积足够写入后与磁盘列文件合并，写入新文件（Vertica 实现）

物化聚合：缓存常使用的一些技术或综合

一种方式：物化视图（标准视图 in 关系数据库），是查询结果的实际副本，被写到磁盘，随底层数据变化而变化，OLTP 应用较少，影响写入性能

物化视图的特殊情况：数据立方体（OLAP 立方体）

![二维的例子，也可能有多维](https://cdn.jsdelivr.net/gh/1935Zz/1935zz.github.io@main/source/img/data-intensive/image-8.png)

优点：某些查询会很快

缺点：缺乏灵活性，只对特定情况查询有效
