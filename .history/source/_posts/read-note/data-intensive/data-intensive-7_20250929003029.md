---
title: 数据密集型应用系统设计（7-8章）
date: 2025-09-28 20:39:32
categories:
   - [Read-Note, 数据密集型应用系统设计]
---


# 分布式数据系统

## 七、事务

![](diagram-2.png)

将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交）、要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况（无论出于何种原因），应用层的错误处理就变得简单很多。

> 事务不是一个天然存在的东西，它是被人为创造出来，目的是简化应用层的编程模型。有了事务，应用程序可以不用考虑某些内部潜在的错误以及复杂的并发性问题，这些都可以交给数据库来负责处理（我们称之为安全性保证）。

### **深入理解事务**

事务与可扩展性并不完全对立，也不是必备功能

**ACID 含义**

原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability）

与 ACID 对立，BASE，基本可用性（BasicallyAvailable），软状态（Softstate）和最终一致性（Eventualconsistency）

**原子性**

在出错时中止事务，并将部分完成的写人全部丢弃。如果事务已经中止，应用程序可以确定没有实质发生任何更改，所以可以安全地重试

**一致性**

对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）。例如，对于一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。

本质上要求应用层来维护状态一致，应用程序有责任正确地定义事务来保持一致性

**隔离性**

多个客户端访问相同记录的并发问题

并发执行的多个事务相互隔离，它们不能互相交叉

**持久性**

保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失

**单对象与多对象事务操作**

原子性和隔离性主要针对客户端在同一事务中包含多个写操作时，数据库所提供的保证。单对象也同样适用。

**多对象事务的必要性**

关系数据模型，某一行是另一个外键。

文档数据模型，可能需要一次更新多个文档

二级索引数据库，需要同步更新索引

**处理错误与中止**

重试中止的事务虽然是一个简单有效的错误处理机制，但它并不完美

### 弱隔离级别

可串行化性能较低，为了不牺牲性能，更多倾向于采用较弱的隔离级别，它可以防止某些但并非全部的并发问题

#### **读-提交**

读数据库只能看到已成功提交的数据（防止脏读）

写数据库时只会覆盖已成功提交的数据（防止脏写）

防止看到部分更新，防止写操作回滚时看到被回滚的数据（实际这些数据不会提交）

对于是尚未提交事务的先前的写入，防止另一个事务提交覆盖先前的写入。通常通过推迟第二个写请求，直到前面的的事务提交

![](image-34.png)

**实现读-提交**

通常采用行级锁来防止脏写

防止脏读，一种选择是使用相同的锁，所有试图读取该对象的事务必须先申请锁，事务完成后释放锁。但运行时间较长的写事务会导致许多只读的事务等待太长时间，这会严重影响只读事务的响应延迟

大多数据库方法：对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。在事务提交之前，所有其他读操作都读取旧值；仅当写事务提交之后，才会切换到读取新值

#### **快照级别隔离与可重复读**

![读倾斜，对于读提交的问题，不可重复读](image-33.png)

快照级别隔离，解决常见手段。其总体想法是，每个事务都从数据库的一致性快照中读取，事务一开始所看到是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到该特定时间点的旧数据。

**实现快照级别隔离**

写加锁防止脏写，但读取不加锁

实现：保留了对象多个不同的提交版本，这种技术因此也被称为多版本并发控制（Multi-VersionConcurrencyControl，MVCC）

PostgreSQL 实现方式（其它类似）：每行额外两个字段，created\_by 字段表示创建该行事务 ID，deleted\_by 字段表示删除该行事务 ID，更新内部转换为一个删除操作和一个创建操作

**快照可见性规则**

1. 事务开始时列出当前正在进行的事务，之后忽略这些事务的写入

2. 中止事务不可见

3. 较晚事务不可见

4. 除此之外的事务写入可见

**索引和快照级别隔离**

一种方案：索引直接指向对象的所有版本，然后想办法过滤对当前事务不可见的那些版本

另一种方案：追加式 B-tree，每个写入事务创建新的 B-treeroot，修改时创建新的修改副本，拷贝必要的内容，让上面的节点指向新创建的节点

#### **防止更新丢失**

对于 read-modify-write 过程，两个事务在同样的数据对象执行类似操作，由于隔离性，第二个写操作不包含第一个事务修改后的值，导致第一个事务修改至可能会丢失

解决方案：

**原子写操作**

数据库层

UPDATEcountersSETvalue=value+1WHEREkey='foo'并发安全

**显式加锁**

数据库不支持内置原子操作，应用程序显示锁定待更新对象，如 select...forupdate

**自动检测更新丢失**

原子操作和锁本质是让“读-修改-写回”的序列串行执行，另一种思路是先让他们并发执行，如果事务管理器检测到了更新丢失风险，则会中断当前事务，强制回退到安全的“读-修改-写回”方式

借助快照级别隔离可以高效执行检查，但不是所有数据库支持检测更新丢失

**原子比较和设置**

只有在上次读取的数据没有发生变化时才允许更新；如果已经发生了变化，则回退到“读-修改-写回”方式。

**冲突解决与复制**

多副本数据库，不同节点可能会并发修改数据，需采取额外措施防止丢失更新

#### **写倾斜与幻读**

设想这样一个例子：你正在开发一个应用程序来帮助医生管理医院的轮班。通常，医院会安排多个医生值班，医生也可以申请调整班次（例如他们自己生病了），但前提是确保至少一位医生还在该班次中值班。

现在情况是，Alice 和 Bob 是两位值班医生。两人碰巧都感到身体不适，因而都决定请假。不幸的是，他们几乎同一时刻点击了调班按钮。

每笔事务总是首先检查是否至少有两名医生目前在值班。如果是的话，则有一名医生可以安全里离开。由于数据库正在使用快照级别隔离，两个检查都返回有两名医生，所以两个事务都安全地进入到下一个阶段。接下来 Alice 更新自己的值班记录为离开，同样，Bob 也更新自己的记录。两个事务都成功提交，最后的结果却是没有任何医生在值班，显然这违背了至少一名医生值班的业务要求。

**定义写倾斜**

广义的更新丢失。如果两个事务读取相同的一组对象，更新其中一部分，不同的事务可能更新不同的对象，可能发生写倾斜，不同的事务如果更新同一个对象，可能发生脏写或更新丢失

**更多写倾斜的例子**

会议室预定系统，多人游戏，声明一个用户名，防止双重开支

**为何产生写倾斜**

写倾斜的规律

1. select 查询满足条件的行（例如，至少有两名医生正在值班，同一时刻房间没有预订，棋盘的某位置没有出现数字，用户名还没有被占用，账户里还有余额等）

2. 根据查询的结果，应用层决定是否继续操作

3. 如果继续，发起写入

写入会改变步骤 2 做出决定的前提条件，即提交写入后重复执行步骤一的 select 查询，会返回完全不同的结果

这种在一个事务中的写入改变了另一个事务查询结果的现象，称为幻读

### 串行化

* 隔离级别难以理解，不同数据库实现不一致

* 检查应用层代码，很难判断它在特定隔离级别下是否安全

* 缺乏工具检测竞争状况

解决方案：串行化，即使事务可能会并行执行，最终结果与每次一个即串行执行结果相同，防止所有竞争条件

#### 实际串行执行

在一个线程上按顺序方式每次只执行一个事务

**采用存储过程封装事务**

![](image-37.png)

**分区**

串行执行所有事务使得并发控制更加简单，但是数据库的吞吐量被限制在单机单个 CPU 核。虽然只读事务可以在单独的快照上执行，但是对于那些高写入需求的应用程序，单线程事务处理很容易成为严重的瓶颈。

对数据分区，每个事务只在单个分区内读写数据，每个分区都可以有自己的事务处理线程且独立运行

跨分区事务需要额外的协调，性能要低很多

**串行执行小结**

* 事务必须简短而高效，否则一个缓慢的事务会影响到所有其他事务的执行性能。

* 仅限于活动数据集完全可以加载到内存的场景。有些很少访问的数据可能会被移到磁盘，但万一单线程事务需要访问它，就会严重拖累性能。

* 写入吞吐量必须足够低，才能在单个 CPU 核上处理；否则就需要采用分区，最好没有跨分区事务。

* 跨分区事务虽然也可以支持，但是占比必须很小

#### 两阶段加锁

two-phaselocking,2PL

读写锁

第一阶段事务执行前获取锁，第二阶段事务结束释放锁

死锁，数据库系统自动检测

缺点：性能下降，访问延迟不确定性，可能因为锁等待很长时间

**谓词锁**

防止写倾斜和幻读（如会议室预定场景）

谓词锁：不属于某个特定对象，作用于满足某些搜索条件的所有查询对象

谓词锁会限制如下访问：

* 如果事务 A 想要读取某些满足匹配条件的对象，例如采用 SELECT 查询，它必须以共享模式获得查询条件的谓词锁。如果另一个事务 B 正持有任何一个匹配对象的互斥锁，那么 A 必须等到 B 释放锁之后才能继续执行查询

* 如果事务 A 想要插入、更新或删除任何对象，则必须首先检查所有旧值和新值是否与现有的任何谓词锁匹配（即冲突）。如果事务 B 持有这样的谓词锁，那么 A 必须等到 B 完成提交（或中止）后才能继续

**索引区间锁**

谓词锁性能差，大部分 2PL 使用索引区间锁（next-keylocking），本质是对谓词锁的简化或近似



#### 可串⾏化的快照隔离

提供了完整的可串⾏性保证，⽽性能相⽐于快照隔离损失很⼩

基于快照隔离，读取基于快照，同时增加了相关算法检测写入冲突来决定是否中止事务

事务基于某些前提条件成立而执行，如果提交时条件发生变化，则需中止

数据库需检测事务是否会修改其他事物的查询结果，具体分以下 2 种情况

1. 是否读取的是一个过期的 MVCC 对象

事务读取时是其它某个事务未提交的对象，提交时该对象已经被其它某个事务提交，

* 写入是否影响即将完成的读取

![](<截屏2025-06-24 17.43.41.png>)

事务 42 的写影响了事务 43 的读取（42 先于 43 提交）



## 八、分布式系统挑战

![](diagram-3.png)

与单节点系统差异显著，会出现各种问题

核心：构建可靠系统

认清分布式系统状态本质->评估所发生的各种故障

### 故障与部分失效

单节点运行具有确定性，当硬件正常时，主要问题是 bug，且相同的操作通常会产生相同的结果

分布式系统会出现部分失效，即一部分工作正常，一部分出现故障，难点在于部分失效的不确定：如有时网络正常，有时失败

#### 云计算和超算

构建大规模计算系统思路

1. 高性能计算，包含成千上万个 CPU 的超级计算机构成一个庞大的集群，通常用于计算密集型科学计算

2. 云计算

不同构建方式处理错误方法也不同。高性能计算通常会对任务保存快照，出现故障停止整个集群，修复后从最近快照执行（更像是一个单节点系统）

本书重点是基于互联网的服务，与 HPC 不同

1. 大部分是在线服务

2. HPC 通常采用专用的硬件，每个节点可靠性高，节点间主要通过共享内存或远程内存直接访问等技术通信。云计算节点多由通用机器构建，单节点成本低廉

3. 大型数据中心通常基于 IP 和以太网，HPC 通常基于特定的网络拓扑结构

4. 可容忍失败节点，让整体继续工作

5. 数据中心分布全球部署（让用户访问地理靠近的数据中心，降低延迟），HPC 通常假设节点位置靠近

必然面临部分失效，依靠软件系统提供容错机制，即在不可靠的组件上构建可靠的系统

### 不可靠的网络

主要关注分布式无共享系统：通过网络连接的多个节点，网络是跨节点通信唯一路径

互联网大多数据中心内部网络基于异步网络，节点通过网络发送消息到另一个节点，但网络不保证什么时候到达及是否到达。发送到等待响应过程中，可能出错的事情

1. 请求已丢失

2. 请求在某个队列中等待，无法马上发送

3. 远程接收节点已失效（如崩溃或关机）

4. 远程接收节点暂时无法响应

5. 远程接收节点已经完成请求处理，但回复在网络中丢失

6. 远程接收节点已经完成请求处理，回复被延迟处理

![](<截屏2025-06-25 15.51.37.png>)

#### 检测故障

需要自动检测节点失效

#### 超时和无限的延迟

延迟理论无限大，大多数系统无法保障数据包传输的延迟和处理数据包的时间

超时时间不好设置

**网络拥塞和排队**

延迟变化根源往往在于排队

1. 网络交换机处理大量数据包时的排队

2. 目标机器 cpu 均繁忙时，会被操作系统处理排队

3. 虚拟化环境 cpu 切换虚拟机导致的排队

4. tcp 流量控制的排队，以及 tcp 重传引入的延迟

### 不可靠的时钟

许多场景依赖时钟，包括判断请求超时，服务 p99，用户浏览时间，文章发表时间，缓存过期时间……

NTP（Network Time Protocol）网络时间协议：可以根据一组专门的时间服务器调整本地时间


